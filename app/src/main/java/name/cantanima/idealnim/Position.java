package name.cantanima.idealnim;

import android.support.annotation.NonNull;

/**
 * Created by cantanima on 8/8/17.
 */

/**
 * A class to store a position of (x, y) points. The positions can be ordered by lexicographic
 * ordering; that is, (a, b) > (c, d) iff a > b or (a = b and c > d).
 */
public class Position implements Comparable<Position> {

  /**
   * Initializes position to the given values.
   * @param x x-value of new position
   * @param y y-value of new position
   */
  public Position(int x, int y) { a = x; b = y; }

  /**
   * @return x-value of position
   */
  public int get_x() { return a; }

  /**
   * @return y-value of position
   */
  public int get_y() { return b; }

  /**
   * Determines whether the given position is ideal-generated by this one; i.e.,
   * whether it lies "northeast" of this position.
   * @param x x-value of position to test
   * @param y y-value of position to test
   * @return {@literal true} if and only if (x, y) lies "northeast" of this
   */
  public boolean generates(int x, int y) { return a <= x && b <= y; }

  /**
   * Determines whether the given position is ideal-generated by this one; i.e.,
   * whether it lies "northeast" of this position.
   * @param P position to test
   * @return {@literal true} if and only if P lies "northeast" of this
   */
  public boolean generates(Position P) { return generates(P.a, P.b); }

  /**
   * Determines whether this position is generated by the given position; i.e.,
   * whether this lies "northeast" of it.
   * @param x x-value of position to test
   * @param y y-value of position to test
   * @return {@literal true} if and only if this lies "northeast" of (x, y)
   */
  public boolean is_generated_by(int x, int y) { return x <= a && y <= b; }

  /**
   * Determines whether this position is generated by the given position; i.e.,
   * whether this lies "northeast" of it.
   * @param P position to test
   * @return {@literal true} if and only if this lies "northeast" of P
   */
  public boolean is_generated_by(Position P) { return is_generated_by(P.a, P.b); }

  /**
   * Creates a string representation of this: (x, y) .
   * @return a string representation of this
   */
  public String toString() {
    String result = "(";
    result += String.valueOf(a);
    result += ", ";
    result += String.valueOf(b);
    result += ")";
    return result;
  }

  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   * <p>
   * <p>The implementor must ensure <tt>sgn(x.compareTo(y)) ==
   * -sgn(y.compareTo(x))</tt> for all <tt>x</tt> and <tt>y</tt>.  (This
   * implies that <tt>x.compareTo(y)</tt> must throw an exception iff
   * <tt>y.compareTo(x)</tt> throws an exception.)
   * <p>
   * <p>The implementor must also ensure that the relation is transitive:
   * <tt>(x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z)&gt;0)</tt> implies
   * <tt>x.compareTo(z)&gt;0</tt>.
   * <p>
   * <p>Finally, the implementor must ensure that <tt>x.compareTo(y)==0</tt>
   * implies that <tt>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</tt>, for
   * all <tt>z</tt>.
   * <p>
   * <p>It is strongly recommended, but <i>not</i> strictly required that
   * <tt>(x.compareTo(y)==0) == (x.equals(y))</tt>.  Generally speaking, any
   * class that implements the <tt>Comparable</tt> interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   * <p>
   * <p>In the foregoing description, the notation
   * <tt>sgn(</tt><i>expression</i><tt>)</tt> designates the mathematical
   * <i>signum</i> function, which is defined to return one of <tt>-1</tt>,
   * <tt>0</tt>, or <tt>1</tt> according to whether the value of
   * <i>expression</i> is negative, zero or positive.
   *
   * @param other the object to be compared.
   * @return a negative integer, zero, or a positive integer as this object
   * is less than, equal to, or greater than the specified object.
   * @throws NullPointerException if the specified object is null
   */
  @Override
  public int compareTo(@NonNull Position other) {
    int result;
    if (other.a != a) result = a - other.a;
    else result = b - other.b;
    return result;
  }

  protected int a, b;

}
